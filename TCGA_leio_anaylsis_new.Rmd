```{r setup}
library(tidyverse)
library(DESeq2)
library(pheatmap)
```

```{r}
genes <- c('MEF2B', 'HDAC7', 'MEF2C', 'HDAC4', 'MEF2A', 'HDAC5', 'MEF2D', 'HDAC9')
genes <- read_lines('/media/alessio/Data/hypoxia/DBR_analysis_RNAseq_new/Genes_Up_shared_DBR_promoter.txt')
```



# Analysis over LMS only TCGA samples
## Compute Zscore, clustering with kmeans and Heatmap

### read and compute Zscore
```{r}
vst_counts_leio <- read_delim('vst_counts_TGCA_leio.csv') |>
    column_to_rownames('symbol')

# Zscore
Zscore_tab_leio <- t(scale(t(vst_counts_leio)))


genes <- genes[genes %in% row.names(Zscore_tab_leio)]
# select genes
Zscore_mef_hdac_leio <- Zscore_tab_leio[genes, ] |> 
    as.data.frame()
```

### Kmeans
```{r}
# first transpose because we want to clusterize samples
Zscore_mef_hdac_leio_transposed <- t(Zscore_mef_hdac_leio)

# elbow
wss <- numeric()
k_values <- 2:10

for (k in k_values) {
    set.seed(10)
    km <- kmeans(Zscore_mef_hdac_leio_transposed,
                centers = k,
                nstart = 25, algorithm = c("MacQueen"))
    wss[k-1] <- km$tot.withinss
}

plot(k_values, wss, type = 'b', pch = 19)

# result is not clear bu I arbitrary choose 3 :)
kmeans_samples <- kmeans(Zscore_mef_hdac_leio_transposed, centers = 3, nstart = 25)

# clusters of samples 
kmeans_samples$cluster

# for the heatmap
ordered_samples <- rownames(Zscore_mef_hdac_leio_transposed)[order(kmeans_samples$cluster)]
annotation_row <- data.frame(Cluster = factor(kmeans_samples$cluster[ordered_samples]))
rownames(annotation_row) <- ordered_samples
```


### Heatmap Z score
```{r}
paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(Zscore_mef_hdac_leio), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(Zscore_mef_hdac_leio)/paletteLength, max(Zscore_mef_hdac_leio), length.out=floor(paletteLength/2)))

# Plot the heatmap
# png('Heatmap_leio_TCGA_HDAC_MEF.png', res = 600, units = 'cm', height = 35, width = 10)
pheatmap(Zscore_mef_hdac_leio_transposed, 
         show_colnames = T,
         show_rownames = F,
         cluster_rows = T,
         cluster_cols = T,
         annotation_row = annotation_row,
         main = 'Zscore',
         color=myColor,
         breaks=myBreaks,
         cellwidth = 10,
        cellheight = 5)
# dev.off()
```

# Heatmap correlation
```{r}
# Heatmap correlations between zscore
# genes <- c('MEF2B', 'HDAC7', 'MEF2C', 'HDAC4', 'MEF2A', 'HDAC5', 'MEF2D', 'HDAC9', 'HIF1A', 'EPAS1')

Zscore_mef_hdac_hif_leio <- Zscore_tab_leio[genes, ]
cor_mat <- cor(t(Zscore_mef_hdac_hif_leio))

paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(-1, 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(1/paletteLength, 1, length.out=floor(paletteLength/2)))

# png('Corr_heatmap_TCGA_HDAC_MEF.png', res = 600, units = 'cm', height = 10, width = 10)
pheatmap(cor_mat[genes, genes],
         show_colnames = T,          
         cluster_rows = F,
         cluster_cols = F,
         main = 'Pearson corr',
         cellwidth = 15,
         cellheight = 15,
         color=myColor,
         breaks=myBreaks)
# dev.off()
```

# We want to see if the group with low expression of both HDACs and MEF is correlated with more survival
```{r}
# clinical data

# The cluster with less expression is cluster 2
annotation_row_df <- annotation_row |> 
    as.data.frame() |> 
    rownames_to_column('cases.submitter_id')

clinical_leio <- read_tsv('manual_downloaded_samples/clinical.tsv')

# select only the variables of interests
clinical_leio_unique <- clinical_leio |> 
  dplyr::filter(!duplicated(cases.case_id)) |> 
  dplyr::select(cases.submitter_id, demographic.days_to_death, diagnoses.days_to_last_follow_up, demographic.vital_status)

# convert survival time e status
clinical_leio_unique$time <- ifelse(clinical_leio_unique$demographic.days_to_death == '\'--', 
                                clinical_leio_unique$diagnoses.days_to_last_follow_up,
                                clinical_leio_unique$demographic.days_to_death)

clinical_leio_unique$status <- ifelse(clinical_leio_unique$demographic.vital_status == "Dead", 1, 0)

# add the Kmeans group and filter those with no infos of the time

clinical_leio_unique <- clinical_leio_unique |> 
    left_join(annotation_row_df, by = 'cases.submitter_id') |> 
    dplyr::filter(time != '\'--') |> 
    dplyr::mutate(time = as.numeric(time))

clinical_leio_unique$Cluster <- factor(clinical_leio_unique$Cluster)
```

# Kaplan meier
```{r}
library(survival)
library(survminer)

fit <- survfit(Surv(time, status) ~ Cluster, data = clinical_leio_unique)

# png('survival_kmeans_MEF_HDAC_leio.png', height = 12, width = 16, units = 'cm', res = 300)
ggsurvplot(fit,
           pval = TRUE,
           conf.int = F,
           risk.table = F,
           legend.title = '',
           palette = c("#7FDC96", "#FF6D62", "#5F99EA"),
           ggtheme =   theme_bw()
)
# dev.off()
```
# Relationship between the core 33 genes signature and publica data
### TCGA data leio
### heatmap correlation about the signature 33 genes and HDAC MEF
```{r}
core_genes <- c(read_lines('../hypoxia/DBR_analysis_RNAseq_new/Genes_Up_shared_DBR_promoter.txt'), 'NFIA', 'NFIC', 'NFIX')
core_genes <- core_genes[core_genes %in% rownames(Zscore_tab_leio)]


genes_HDAC_MEF <- c('HDAC4', 'HDAC5', 'HDAC7', 'HDAC9', 'MEF2A', 'MEF2B', 'MEF2C', 'MEF2D')
total_genes <- c(core_genes, genes_HDAC_MEF) 
# Heatmap correlations between zscore


Zscore_33_genes_HDC_MEF <- Zscore_tab_leio[total_genes, ]

library(Hmisc)
res <- rcorr(t(Zscore_33_genes_HDC_MEF), type = 'pearson')
cor_mat <- res$r
p_mat <- res$P

cor_mat[p_mat >= 0.05] <- 0

cor_mat_selected <- cor_mat[core_genes, genes_HDAC_MEF]

paletteLength <- 50
myColor <- colorRampPalette(c("blue", "white", "red"))(paletteLength)
# length(breaks) == length(paletteLength) + 1
# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(-1, 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(1/paletteLength, 1, length.out=floor(paletteLength/2)))

H <- pheatmap(cor_mat_selected,
         show_colnames = T,          
         cluster_rows = T,
         cluster_cols = T,
         main = 'Pearson corr',
         color=myColor,
         breaks=myBreaks)
```


